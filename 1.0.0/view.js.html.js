tui.util.defineNamespace("fedoc.content", {});
fedoc.content["view.js.html"] = "      <div id=\"main\" class=\"main\">\n\n\n\n    \n    <section>\n        <article>\n            <pre class=\"prettyprint source linenums\"><code>/**\n * @fileoverview The base class of views.\n * @author NHN Ent. FE Development Team &lt;dl_javascript@nhnent.com>\n */\nimport * as core from './core';\n\nconst util = tui.util;\n\n/**\n * Property for represent all view instance element\n * @type {string}\n */\nconst VIEW_PROP = 'feView';\n\n/**\n * Basic view class\n * @mixes tui.util.CustomEvents\n * @param {HTMLElement} container - base container element\n */\nexport default class View {\n    constructor(container) {\n        container = container || this.createFallbackElement();\n\n        /**\n         * Unique ID for each view instance\n         * @type {string}\n         */\n        this.id = String(View.id);\n\n        /**\n         * Base container element for each view instance\n         * @type {HTMLElement}\n         */\n        this.container = container;\n\n        /**\n         * Sub views\n         * @type {View[]}\n         */\n        this.children = [];\n\n        /**\n         * Parent view\n         * @type {View}\n         */\n        this.parent = null;\n\n        /**\n         * Cache for container bound\n         */\n        this.boundCache = null;\n\n        View.id += 1;\n        dom.setData(container, VIEW_PROP, this.id);\n    }\n\n    /**\n     * Invoke before destroying\n     */\n    beforeDestroy() {}\n\n    /**\n     * Clear instance properties for destroying\n     */\n    clearProperties() {\n        this.beforeDestroy();\n\n        dom.removeElement(this.container);\n\n        this.id = this.parent = this.children =\n            this.container = this.boundCache = null;\n    }\n\n    /**\n     * Destroy view instance\n     * @param {boolean} [onlyChildren=false] - set true then destroy only\n     *  children\n     */\n    destroy(onlyChildren = false) {\n        this.children.forEach(childView => {\n            childView.destroy();\n        });\n\n        if (onlyChildren) {\n            return;\n        }\n\n        this.clearProperties();\n    }\n\n    /**\n     * Get container's size and position. return bounds from\n     *  getBoundingClientRect()\n     *\n     * It return cached bounds until View.boundCache exists for performance iss\n     * ue. if you want re-calculate conatiner's bound then use bound setter or\n     * just clear boundCache\n     * property.\n     * @returns {object} size and position\n     */\n    getBound() {\n        let bound = this.boundCache;\n\n        if (!bound) {\n            bound = this.boundCache =\n                Object.assign({}, dom.getRect(this.container));\n        }\n\n        return bound;\n    }\n\n    /**\n     * Set container's size and position\n     * @param {object} options - options\n     * @param {number} [options.top] - top pixel\n     * @param {number} [options.right] - right pixel\n     * @param {number} [options.bottom] - bottom pixel\n     * @param {number} [options.left] - left pixel\n     * @param {number} [options.width] - width pixel\n     * @param {number} [options.height] - height pixel\n     */\n    setBound({top, right, bottom, left, width, height} = {}) {\n        dom.setBound(\n            this.container,\n            {top, right, bottom, left, width, height}\n        );\n\n        this.boundCache = null;\n    }\n\n    /**\n     * Create fallback element when invoke constructor without container\n     * @returns {HTMLElement} fallback division element\n     */\n    createFallbackElement() {\n        const el = document.createElement('div');\n        document.body.appendChild(el);\n\n        return el;\n    }\n\n    /**\n     * Add child view\n     * @param {View} view - child view to add\n     * @param {function} [before] - function that invoke before add\n     */\n    addChild(view, before = core.noop) {\n        const children = this.children;\n\n        if (children.findIndex(v => view === v) > -1) {\n            return;\n        }\n\n        before.call(view, this);\n\n        // add parent view\n        view.parent = this;\n\n        children.push(view);\n    }\n\n    /**\n     * Remove child views\n     * @param {string|View} id - child view id or instance itself\n     * @param {function} [before] - function that invoke before remove\n     */\n    removeChild(id, before) {\n        const children = this.children;\n        const _id = util.isString(id) ? id : id.id;\n        const index = children.findIndex(v => _id === v.id);\n\n        before = before || core.noop;\n\n        if (index &lt; 0) {\n            return;\n        }\n\n        let view = children[index];\n\n        before.call(view, this);\n\n        children.splice(index, 1);\n    }\n\n    /**\n     * Render view recursively\n     */\n    render() {\n        this.children.forEach(childView => {\n            childView.render();\n        });\n    }\n\n    /**\n     * Invoke function recursively.\n     * @param {function} iteratee - function to invoke child view recursively\n     * @param {boolean} [skipThis=false] - set true then skip invoke with\n     *  this(root) view.\n     */\n    recursive(iteratee = core.noop, skipThis = false) {\n        if (!skipThis) {\n            iteratee(this);\n        }\n\n        this.children.forEach(childView => {\n            childView.recursive(iteratee);\n        });\n    }\n\n    /**\n     * Resize view recursively to parent.\n     * @param {...*} [args] - arguments for supplied to each parent view.\n     */\n    resize(...args) {\n        let parent = this.parent;\n\n        while (parent) {\n            if (util.isFunction(parent._onResize)) {\n                parent._onResize.apply(parent, args);\n            }\n\n            parent = parent.parent;\n        }\n    }\n}\n\n/**\n * @static\n */\nView.id = 0;\n\ntui.util.CustomEvents.mixin(View);\n</code></pre>\n        </article>\n    </section>\n\n\n\n</div>\n\n"